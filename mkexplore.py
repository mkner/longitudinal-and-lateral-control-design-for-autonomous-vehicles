#
#
# mike knerr
#
# some basic routines to load in analysis file
# generated by controllers during simulation runtime
# and display plots across various dimensions

# 
# mk explore
#mk
#v0.17
# 


CONTROLLER_VERSION="0.37"

import numpy as np
import numpy.linalg as nla
import matplotlib.pyplot as plt
#import matplotlib
from math import *
import os
import csv

#Get the current working direcory: os.getcwd()  
#Change the current working direcory: os.chdir()


WAYPOINTS_FILENAME = os.getcwd() + '/racetrack_waypoints.txt'


ANALYSIS_OUTPUT_FOLDER = os.getcwd() +'/analysis_output/'

# use for release version
#ANALYSIS_OUTPUT_FOLDER = os.getcwd() +'/analysis_output/'

print(ANALYSIS_OUTPUT_FOLDER)

def load_waypoints(fname):

    waypoints   = None
    with open(fname) as f:
        waypoints_list = list(csv.reader(f, delimiter=',', \
                    quoting=csv.QUOTE_NONNUMERIC))
            
        waypoints = np.array(waypoints_list)
    return(waypoints)

def load_analysis_file(fname):
    
    analysis_data   = None
    with open(fname) as f:
        analysis_list = list(csv.reader(f, delimiter=',', \
                    quoting=csv.QUOTE_NONNUMERIC))
            
        analysis_data = np.array(analysis_list)
    return(analysis_data)

def create_output_dir(output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

def write_analysis_file(ct_error_data, psi_data, delta_data):#, t_list):
    create_output_dir(ANALYSIS_OUTPUT_FOLDER)
    file_name = os.path.join(ANALYSIS_OUTPUT_FOLDER, 'analysis_data.txt')

    with open(file_name, 'w') as output_file: 
        for i in range(len(delta_data)):
            output_file.write('%3.3f, %3.3f, %2.3f\n' %\
                                  (ct_error_data[i], psi_data[i], delta_data[i]))

 

# delta bounding code
# specify steering limit in deg
# but keep numerics in radians until
# final scaling to steering input range in [-1,1]

def clamp_delta(angle, deg):
    max_angle_deg=deg #70.0
    rad2steer  = 180.0 / max_angle_deg / np.pi
    # scale delta to radians to [-1, 1]
    steering_scaled= rad2steer * angle
    # Clamp the steering command to bounds of simulator
    steering  = np.fmax(np.fmin(steering_scaled, 1.0), -1.0)

    return(steering)

def steering_direction(v1, v2):
        crossproduct = v1[0]*v2[1] - v1[1]*v2[0]
        if crossproduct >= 0 :
            return -1
        return 

def rmse(predictions, targets):
    return np.sqrt(((predictions - targets)**2).mean())


        
#create_output_dir(ANALYSIS_OUTPUT_FOLDER)
 
###########################################################
########### SIMULATOR RUNTIME DUMP ANALYSIS ####################
###########################################################



analysis_file=ANALYSIS_OUTPUT_FOLDER+"analysis_data-v"+ CONTROLLER_VERSION +".txt"

a=load_analysis_file(analysis_file)#\

runtime_time=a[:,0]
runtime_x_pos=a[:,1] 
runtime_y_pos=a[:,2]     
runtime_yaw=a[:,3]  
runtime_velocity=a[:,4] 
runtime_v_tracking=a[:,5]
runtime_v_errors=a[:,6] 
runtime_v_averages=a[:,7]
runtime_nx=a[:,8] 
runtime_ny=a[:,9] 
runtime_ct_errors=a[:,10] 
#
runtime_ct_errors_avg=a[:,11] # v1.16
runtime_psi=a[:,12]
runtime_delta=a[:,13]

np.average(runtime_ct_errors)    
           
np.min(runtime_ct_errors)
np.max(runtime_ct_errors)

mps2mph=2.237
mps2kmph=3.6

min(runtime_velocity)*mps2mph
max(runtime_velocity)*mps2mph
np.average(runtime_velocity)*mps2mph
    
np.round(np.average(runtime_v_errors*mps2mph),2)

np.round(np.average(runtime_v_errors)*mps2mph,2)

rmse(runtime_velocity,runtime_v_tracking)

rmsev=np.round(rmse(runtime_velocity,runtime_v_tracking)*mps2mph,2)
print()
print ("RMS error velocity: "+ str(rmsev)+" (mph)")


# PLOTS #####################################


# velo
"""
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("velocity (kmph)")
plt.plot(runtime_time,ms2kmph*runtime_velocity)

plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("velocity (kmph)")
plt.plot(runtime_time,ms2kmph*runtime_v_tracking)
"""

# mph
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("velocity (mph)")
plt.plot(runtime_time,mps2mph*runtime_velocity)

plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("velocity (mph)")
plt.plot(runtime_time,mps2mph*runtime_v_tracking)

# LOOK AT yaw rate

plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("yaw (deg)")
plt.plot(runtime_time,np.rad2deg(runtime_yaw))

# yaw rate center on zero as due south
yaw_adj=runtime_yaw+np.pi/2
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("yaw (deg)")
plt.plot(runtime_time,np.rad2deg(yaw_adj))


# LOOK AT ct errors
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("crosstrack error")
plt.plot(runtime_time,runtime_ct_errors)

# LOOK AT ct errors positive only
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("crosstrack error")
plt.plot(runtime_time,np.absolute(runtime_ct_errors))

# ct errors running avg
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("crosstrack error avg")
plt.plot(runtime_time,np.absolute(runtime_ct_errors_avg))



# LOOK AT delta

plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("delta (deg)")
plt.plot(runtime_time[:-10],np.rad2deg(runtime_delta[:-10]))

#plt.plot(runtime_time,np.rad2deg(runtime_delta))



# velo
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("velocity (kmph)")
plt.plot(runtime_time,3.6*runtime_velocity)

# LOOK AT ct errors
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("time (s)");plt.ylabel("crosstrack error")
plt.plot(runtime_time,runtime_ct_errors)


############### other down here

# position

plt.grid(True)
plt.xlabel("x");plt.ylabel("y")
plt.plot(runtime_x_pos,runtime_x_pos)

# LOOK AT ct errors
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("iteration");plt.ylabel("crosstrack error")
plt.plot(ix,runtime_ct_errors)

# LOOK AT psi
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("iteration");plt.ylabel("psi")
plt.plot(ix,runtime_psi)

# LOOK AT delta
ix = np.arange(len(a))
plt.grid(True)
plt.xlabel("iteration");plt.ylabel("delta")
plt.plot(ix,runtime_delta)




############################################################
############################################################  

